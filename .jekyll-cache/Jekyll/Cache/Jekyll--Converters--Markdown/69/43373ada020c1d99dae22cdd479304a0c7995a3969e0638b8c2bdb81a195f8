I"Â5<div id="post">
    <video autoplay="" style="display: block; width: 80%; height: 80%; margin: 20px auto;" controls="">
        <source src="https://thumbs.gfycat.com/OfficialFlatAnnelida-mobile.mp4" type="video/mp4" />
        <source src="https://giant.gfycat.com/OfficialFlatAnnelida.mp4" type="video/mp4" />
        <source src="https://thumbs.gfycat.com/OfficialFlatAnnelida-mobile.mp4" type="video/mp4" />
    </video>
    <h2>Oh yeah, itâ€™s all coming together</h2>
    <p>
        If youâ€™re comfortable with the differences between dictionaries and modules, skip ahead to the section about modules where I explain directory layout and importing and contrast modules with object hierarchies.
    </p>
    <h2>What are dictionaries again?</h2>
    <p>
        Imagine a magical backpack that can store as much information as you can fit in memory. The one rule of using the magic backpack, is that <b>each time you need a new pocket or location to store something in it, you have to give the backpack a name</b> to reference the new information with.
    </p>
    <div>
        <img src="/assets/images/blog/sorting-python/dictionaries_python.png" alt="" srcset="" />
    </div>
    <h2>Issues with Nesting</h2>
    <p>
        Forgetting the name, or a <code class="code-pink">KeyError</code>, is a common error for beginners to struggle with. To minimize the number of KeyErrors, it is common to store the key in a variable or list for convenient access (imagine reading a tableâ€™s column headers with <code class="code-pink">.readline()</code>).
    </p>
    <p>
        Another cause of the <code class="code-pink">KeyError</code> is a complex nested structure of lists and dictionaries with a complex accessing strategy. To DRY up your code a little, a lambda expression might be the right tool to access your buried data!
    </p>
    <img src="/assets/images/blog/sorting-python/lambda.png" alt="" srcset="" />
    <p>
        Remember that even though the <code class="code-pink">KeyError</code> may be simple to resolve, discovering an error is the expensive part, itâ€™s not just about how extreme or how deleterious the error might seem (like with respect to closed threads/processes/connections).
    </p>
    <h2>Whatâ€™s with the brackets?</h2>
    <p>
        The bracket syntax reminds us that finding one object out of many with a dictionary is a lot like finding something in a list (or an array)! Instead of using a numerical index to reference a data element, the hashmap, or dictionary, puts a string through a special type of mathematical function called a hash function.
    </p>
    <p>
        The hash function can digest keys (strings of different lengths) into entropically distinct strings that can be used with a standard lookup table. But remember that the computer doesnâ€™t need to store the key, but you need to keep both the keys and the values in mind while youâ€™re programming.
    </p>
    <blockquote style="color: blue;">
        NOTE: Having predictable names for dictionary members is a lot like naming variables in your code. Why?
    </blockquote>
    <p>
        Also, dictionaries can be useful when storing system-wide configurations. Alternatives include using a module (or similarly an <code class="code-pink">.ini</code>), or using <a href="https://matthewralston.github.io/assets/img/pitbull_worlwide_global_variable.jpg">global variables.</a> Some variables or configurations might not be available until runtime, and passing them into functions together prevents the need for complicated function signatures. If none of the previous statement made sense, Iâ€™d look up Python3â€™s signature feature: type hints in function signatures!
    </p>
    <h2>Modules</h2>
    <p>
        Ah, so now that weâ€™ve touched the basics on accessing data with hashed strings or â€˜keysâ€™ with dictionaries, what are the biggest differences between dictionaries and modules?
    </p>
    <p>
        Well, modules (and the submodule) are often pieces of Python code that can be loaded into memory with a <code class="code-pink">import</code> statement. Occassionally, they can be config files (<code class="code-pink">config.py</code> is a common names) that store global, program-wide configurations for the way the program functions. Dictionaries store data. Modules often store code.
    </p>

    <blockquote style="color: green;">
        Tip: If modules store code, that means they can be installed with <code class="code-pink">pip</code>. <a href="https://realpython.com/what-is-pip/">Click here</a> to learn more about module installion.
    </blockquote>

    <p>
        Also, modules have a very different syntax for accessing data. They use a dot syntax similar to what some readers may have seen in object/class hierarchies in other languages. For example, BioPython users may need to familiarize themselves with <code class="code-pink">Seq</code> and <code class="code-pink">SeqRecord</code> objects. Unless you import those modules directly, youâ€™ll have to access the classes for those objects from their submodules underneath the main module.
    </p>
    <h2>Modules, submodules, classes, and objects</h2>
    <p>
        That last sentence was confusing! What did it mean?
    </p>
    <p>
        Okay, so letâ€™s take the BioPython module <code class="code-pink">Bio</code> for example and letâ€™s see how importing different submodules works. Below, the for loop is â€˜iteratingâ€™ or looping through records being read from a fasta file â€˜example.fastaâ€™. The <code class="code-pink">record</code> object in this case, is a <code class="code-pink">SeqRecord</code> object. But wait, we didnâ€™t load the <code class="code-pink">SeqRecord</code> submodule at all! How is the parsers making those records if we havenâ€™t loaded it?
    </p>
    <img src="/assets/images/blog/sorting-python/bio-python.png" alt="" srcset="" />
    <p>
        It turns out that the submodule <code class="code-pink">SeqIO</code> has already loaded the <code class="code-pink">SeqRecord</code> submodule for us, which in turn has loaded the <code class="code-pink">Seq</code> submodule. How confusing! Behind the scenes, there is a lot of importing going on, and we got a lot of mileage out of the much simpler submodule! We have access to the <code class="code-pink">Seq</code> objects, including reverse complementation methods, for free!
    </p>
    <h2>module.function or class.method</h2>
    <p>
        Okay, so now we know that importing submodules can be just as effective as loading the whole module. Now what? Well, did you notice how we didnâ€™t need to â€˜callâ€™ <code class="code-pink">SeqIO()</code> or assign its return to an instance or variable name like below?
    </p>
    <img src="/assets/images/blog/sorting-python/module.fn.png" alt="" />
    <p>
        That means we are working instead with a module, because we could use the function <code class="code-pink">parse</code> under the <code class="code-pink">SeqIO</code> â€˜namespaceâ€™ (a place to store names of constants/variables, functions, and classes) without building an object first. While weâ€™re on the subject of modules vs classes/objects, the last line above would have been an example of a â€˜methodâ€™ call. A method is a fancy name for a function that is tied to an instance or object created from a class.
    </p>
    <p>
        But notice how the call to <code class="code-pink">SeqIO.parse</code> in the first for loop example is similarly structured to how the method call would be structured in the second example. The function or method <code class="code-pink">.parse</code> follows the module or objectâ€™s name. In the first example, we reference the submodule directly without assignment. In the second example <code class="code-pink">seq_parser</code>, is a variable that we have deliberately chosen to have a helpful name. It could just as well be called <code class="code-pink">foo</code> and the method call would be <code class="code-pink">foo.parse.</code>
    </p>
    <p>
        This syntax doesnâ€™t have a formal name but in this blog Iâ€™ll refer to the concept of <code class="code-pink">module.submodule</code>, <code class="code-pink">module.function</code>, <code class="code-pink">class.method</code>, or <code class="code-pink">module.class</code> as the dot syntax. The dot syntax results from where in the moduleâ€™s hierarchy of modules and submodules a piece of code (the class or function) is defined. You might note that the module hierarchy can be described as a tree.
    </p>
    <p>
        In short, importing code in Python can seem intimidating at first without a primer on the foundations of the hierarchical system. But for students of bioinformatics and biology, the hierarchy and inheritance properties might seem extremely logical.
    </p>
    <h2>How to build your first module</h2>
    <p>From the <a href="http://docs.python.org/3/tutorial/modules.html">Python documentation:</a></p>

    <blockquote style="padding: 30px;">If you quit from the Python interpreter and enter it again, the definitions you have made (functions and variables) are lost. Therefore, if you want to write a somewhat longer program, you are better off using a text editor to prepare the input for the interpreter and running it with that file as input instead. This is known as creating a script. As your program gets longer, you may want to split it into several files for easier maintenance. You may also want to use a handy function that youâ€™ve written in several programs without copying its definition into each program.</blockquote>

    <p>
        Modules are incredibly useful. Youâ€™ve probably seen some modules that can even be downloaded to your computer through a tool called <code class="code-pink">pip</code> via the Python Package Index (PyPI). These packages are registered with the index and are typically importable, with BioPython and boto3 being excellent examples.
    </p>
    <p>
        But how do we make a module? What files are necessary to compose a module? A module can be either a single file <b>or</b> a directory. Thatâ€™s it! Itâ€™s that simple. A module in Python is either a single file <code class="code-pink">mymodule.py</code> becomes <code class="code-pink">import mymodule</code> and youâ€™re ready to go! Or if your module is a directory, you would still use <code class="code-pink">import mymodule</code> to import the code in <code class="code-pink">mymodule/</code>.
    </p>
    <p>
        Whatever the case may be, the code of your module (either the file or the directory) must be known by the <code class="code-pink">PYTHONPATH</code> variable, which typically points to a standard location on Linux like <code class="code-pink">path/to/python/lib/python3.7/site-packages/</code>. So <code class="code-pink">$PYTHONPATH</code> is a shell variable (like <code class="code-pink">$PATH)</code> that controls how Python is able to find a module on the filesystem. Okay so far?
    </p>
    <blockquote>
        NOTE: To read the preceeding path, note first that Python can be installed in principle in several locations on your machine. I use a version manager called <a href="https://github.com/pyenv/pyenv">pyenv</a> to manage my Python versions and virtual environments. On my machine, my path is <code class="code-pink">home/matt/.pyenv/versions/python3.7</code>. In this case, that takes the place of the phony <code class="code-pink">path/to/python</code>. So therefore modules are installed into the <code class="code-pink">lib/</code> directory of the python installation, under the category of <code class="code-pink">python3.7/</code>-associated libraries and under the subdirectory <code class="code-pink">site-packages/</code>. Wow!
    </blockquote>
    <blockquote style="color: red;">
        WARNING: Note that <span style="color: black;">language version managers</span> like rvm and pyenv are different types of software from <span style="color: black;">version control systems</span> like csv, svn, and git.
    </blockquote>
    <p>
        So what goes in the single-file module? Anything. No really. You can put whatever you want into a single file. Iâ€™d suggest making the major methods well documented and including them in your <code class="code-pink">README.md</code>, wiki, or Sphinx documentation if you can.
    </p>
    <p>
        How about in a directory-style module? This is where it gets one step trickier than <b>anything</b> lol. Uh, you have to put this file called <code class="code-pink">__init__.py</code> in the directory named <code class="code-pink">mymodule</code> and thatâ€™s basically it. Everything else that goes into the directory becomes code associated with <code class="code-pink">mymodule</code> and can be source like this: <code class="code-pink">from module import submodule</code>.
    </p>
    <p>
        The directory structure looks roughly like this:
    </p>
    <img src="/assets/images/blog/sorting-python/dir_structure.png" alt="" srcset="" />
    <h2>Review</h2>
    <p>
        Okay! We covered more material in this post than you might realize. We learned some dos and donâ€™ts of dictionaries. We learned some basic principles of modules and the import system. Then we learned that module/submodule, superclass/class, and module/function relationships can be defined with hierarchical tree structures. And finally, we learned how to build a module from either a simple file or from a directory with an <code class="code-pink">__init__.py</code> file in it.
    </p>
    <p>
        Iâ€™m glad you read this article! If you enjoyed the content, be sure to check out the beginner tag and upvote the article on social media! Thanks for your support.
    </p>
</div>
:ET